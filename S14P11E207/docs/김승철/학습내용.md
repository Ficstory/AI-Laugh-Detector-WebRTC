React

- **컴포넌트 기반 설계**: 화면을 작은 단위로 쪼개서 재사용/유지보수 쉽게 구성
- **Props / State**: 데이터 전달(부모→자식), 화면 상태 관리

```jsx
// RoomCard.tsx
type Room = { id: string; title: string; players: number };

type Props = {
  room: Room;
  onJoin: (roomId: string) => void;
};

export function RoomCard({ room, onJoin }: Props) {
  return (
    <div style={{ border: "1px solid #ddd", padding: 12, borderRadius: 8 }}>
      <h3>{room.title}</h3>
      <p>참가자: {room.players}명</p>
      <button onClick={() => onJoin(room.id)}>입장</button>
    </div>
  );
}
```

```jsx
// Lobby.tsx (부모)
import { RoomCard } from "./RoomCard";

const rooms = [
  { id: "r1", title: "웃음배틀 #1", players: 1 },
  { id: "r2", title: "웃참 고수방", players: 2 },
];

export function Lobby() {
  const handleJoin = (roomId: string) => {
    alert(`방 입장: ${roomId}`);
  };

  return (
    <div style={{ display: "grid", gap: 12 }}>
      {rooms.map((room) => (
        <RoomCard key={room.id} room={room} onJoin={handleJoin} />
      ))}
    </div>
  );
}
```

- **Hooks**: `useState`, `useEffect` 중심으로 생명주기/비동기 흐름 처리

```jsx
import { useEffect, useState } from "react";

type Room = { id: string; title: string };

export function LobbyWithFetchMock() {
  const [rooms, setRooms] = useState<Room[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // "API 호출" 흉내
    const timer = setTimeout(() => {
      setRooms([
        { id: "r1", title: "웃음배틀 #1" },
        { id: "r2", title: "마이크 ON 필수방" },
      ]);
      setLoading(false);
    }, 800);

    // cleanup (언마운트 시 실행)
    return () => clearTimeout(timer);
  }, []); // 빈 배열 = 처음 마운트 때 1번만

  if (loading) return <p>로비 로딩중...</p>;

  return (
    <ul>
      {rooms.map((r) => (
        <li key={r.id}>{r.title}</li>
      ))}
    </ul>
  );
}
```

```jsx
import { useEffect, useState } from "react";

type Room = { id: string; title: string };

export function LobbyWithFetchMock() {
  const [rooms, setRooms] = useState<Room[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // "API 호출" 흉내
    const timer = setTimeout(() => {
      setRooms([
        { id: "r1", title: "웃음배틀 #1" },
        { id: "r2", title: "마이크 ON 필수방" },
      ]);
      setLoading(false);
    }, 800);

    // cleanup (언마운트 시 실행)
    return () => clearTimeout(timer);
  }, []); // 빈 배열 = 처음 마운트 때 1번만

  if (loading) return <p>로비 로딩중...</p>;

  return (
    <ul>
      {rooms.map((r) => (
        <li key={r.id}>{r.title}</li>
      ))}
    </ul>
  );
}

```

- **렌더링 흐름**: 상태 변경 → 리렌더링, 의존성 배열로 불필요 렌더 최소화

```jsx
import { useState } from "react";

export function ReadyToggle() {
  const [isReady, setIsReady] = useState(false);

  return (
    <div>
      <p>현재 상태: {isReady ? "✅ 준비 완료" : "⏳ 대기중"}</p>
      <button onClick={() => setIsReady((prev) => !prev)}>
        {isReady ? "준비 취소" : "준비하기"}
      </button>
    </div>
  );
}
```

- **라우팅(React Router)**: 로비/매칭/방/결과 화면 전환 구조 설계

```jsx
// App.tsx
import { BrowserRouter, Routes, Route, Link, useParams } from "react-router-dom";

function LobbyPage() {
  return (
    <div>
      <h1>로비</h1>
      <Link to="/room/r1">방 r1 입장</Link>
    </div>
  );
}

function RoomPage() {
  const { roomId } = useParams();
  return (
    <div>
      <h1>방: {roomId}</h1>
      <Link to="/result">결과 보기</Link>
    </div>
  );
}

function ResultPage() {
  return <h1>결과 페이지</h1>;
}

export default function App() {
  return (
    <BrowserRouter>
      <nav style={{ display: "flex", gap: 12 }}>
        <Link to="/">로비</Link>
        <Link to="/result">결과</Link>
      </nav>

      <Routes>
        <Route path="/" element={<LobbyPage />} />
        <Route path="/room/:roomId" element={<RoomPage />} />
        <Route path="/result" element={<ResultPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

TypeScript

- **타입 안정성**: props, API 응답, 실시간 메시지를 타입으로 고정

```jsx
// domain.ts
export type User = {
  id: string;
  nickname: string;
};

export type Room = {
  id: string;
  title: string;
  players: number;
};
```

```jsx
// RoomTitle.tsx
import type { Room } from "./domain";

type Props = {
  room: Room;
};

export function RoomTitle({ room }: Props) {
  return <h2>{room.title} ({room.players}명)</h2>;
}
```

- **interface / type**: 객체 구조 정의 vs 유니온/교차 타입 조합

```jsx
// interface: 객체 형태 확장(extends)할 때 편함
export interface BaseMessage {
  type: string;
  ts: number;
}

// type: 유니온/조합 만들기 편함
export type RoomId = string;
export type UserId = string;
```

- **유니온 타입(Union)**: 메시지 타입 분기(예: `chat | match | signal`)

```jsx
export type ChatMessage = {
  type: "chat";
  roomId: string;
  payload: { text: string; sender: string };
};

export type MatchMessage = {
  type: "match";
  roomId: string;
  payload: { status: "waiting" | "matched" };
};

export type SignalMessage = {
  type: "signal";
  roomId: string;
  payload: { kind: "offer" | "answer" | "ice"; sdp?: string; candidate?: string };
};

export type WSMessage = ChatMessage | MatchMessage | SignalMessage;
```

- **제네릭(Generic)**: `ApiResponse<T>` 같은 공통 응답 타입 패턴

```jsx
import { useEffect, useState } from "react";
import { fetchRooms } from "./api";
import type { Room } from "./types";

export function LobbyTS() {
  const [rooms, setRooms] = useState<Room[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchRooms().then((res) => {
      if (!res.ok) return setError(res.error ?? "unknown error");
      setRooms(res.data);
    });
  }, []);

  if (error) return <p>에러: {error}</p>;

  return (
    <ul>
      {rooms.map((r) => (
        <li key={r.id}>{r.title}</li>
      ))}
    </ul>
  );
}
```

- **타입가드/내로잉**: 런타임 분기에서 안전하게 타입 좁히기

```jsx
import type { WSMessage } from "./ws-types";

function isObject(v: unknown): v is Record<string, unknown> {
  return typeof v === "object" && v !== null;
}

export function isWSMessage(v: unknown): v is WSMessage {
  if (!isObject(v)) return false;
  const t = v["type"];
  const roomId = v["roomId"];
  const payload = v["payload"];

  if (t !== "chat" && t !== "match" && t !== "signal") return false;
  if (typeof roomId !== "string") return false;
  if (!isObject(payload)) return false;

  // 여기서 더 엄격하게 payload도 검사 가능 (필요한 만큼만)
  return true;
}
```

Zustand

- **Store 구조화**: 로그인/유저, 매칭, 방 상태를 전역에서 관리
- **Selector 패턴**: 필요한 상태만 구독해서 리렌더 최소화
- **State Slice**: 기능 단위로 store 분리(예: auth/room/match)
- **Persist**: 새로고침에도 유지되는 상태 저장 옵션

TailwindCSS

- **Utility-first 스타일링**: 클래스 조합으로 빠른 UI 구성
- **레이아웃**: `flex/grid`로 화면 구조 잡기
- **반응형**: breakpoints로 모바일/데스크탑 대응
- **컴포넌트화 패턴**: 버튼/카드/모달 등 공통 UI 스타일 통일
- **상태 UI**: 로딩/에러/disabled 등 상태별 표현 규칙화

Docker

- **환경 통일**: 개발/배포 환경 차이를 최소화
- **Dockerfile**: 프론트/백엔드 빌드 및 실행 이미지 구성
- **docker-compose**: 서비스 묶음 실행(front/back/ws/openvidu)
- **환경변수(.env)**: 키/서버주소 등 설정 분리
- **네트워크/포트**: 컨테이너 간 통신 구조 이해

WebSocket

- **실시간 통신**: 채팅/매칭 상태/이벤트 전달 기반
- **메시지 스키마**: `{ type, roomId, payload }` 같은 구조 설계
- **룸 개념**: 같은 방 사용자에게 브로드캐스트
- **재연결 전략**: 끊김/복구 대응(네트워크 불안정 대비)
- **Heartbeat**: ping/pong으로 연결 상태 확인

WebRTC

- **미디어 입력**: `getUserMedia`로 카메라/마이크 스트림 획득
- **P2P 연결**: `RTCPeerConnection` 기반 통신
- **시그널링**: offer/answer 교환으로 연결 협상
- **ICE Candidate**: 네트워크 경로 탐색(STUN/TURN 포함)
- **트랙 제어**: mute/camera off, 장치 변경 등 제어 흐름

OpenVidu

- **WebRTC 추상화**: 세션/토큰 기반으로 영상 연결 관리 단순화
- **Session / Token**: 방 생성, 참가자 인증/접속 흐름
- **Publish / Subscribe**: 내 영상 송출 + 상대 영상 구독
- **이벤트 처리**: stream 생성/종료, 참가자 입장/퇴장 핸들링
- **도커 기반 운영**: 서버 구동 및 배포 구조와 연계

간략하게 이해한 webRTC와 webSocket

webRTC : **영상/음성 데이터(미디어)가 흐르는 실제 통로**고, 연결만 되면 **브라우저 ↔ 브라우저(P2P)**

webSocket : 연락망, socket이 알려주는 건 **WebRTC 연결을 만들기 위한 재료들(연결 협상 정보)**

1:1의 경우 동작 순서
0. 사용자가 프론트에서 방입장 ⇒ 백으로 방에 입장한 사람 수, 토큰 확인 등 입장 가능한지 확인

1.  카메라 및 마이크 스트림을 가져옴(webex에서 카메라 및 마이크 세팅하는 과정이라고 판단)
2. p2p연결을 위한 준비(엔진 세팅)
3. webrtc 연결을 위한 정보(SDP(offer/answer): 코덱/해상도/방식, ICE candidate: 연결가능한 경로 후보)를 송신
4. 반대로 수신
5. 3,4에서 교환한 정보를 바탕으로 연결
6. rtc로 소통 시작(영상정보 교환시작)

아래는 gpt를 통해 확인한 동작 프로세스

## 실제 동작 프로세스 (1:1 기준, 방 입장~연결 완료까지)

아래 순서가 거의 정석 플로우야.

### 0) 방 입장 & 상대 존재 확인

**FE**

1. 사용자가 “방 입장” 누름
2. WebSocket 연결 `ws.connect()`
3. `join-room(roomId)` 메시지 전송

**BE**

1. 해당 소켓을 room에 붙임(예: `rooms[roomId].add(socket)`)
2. 현재 방에 몇 명 있는지 파악
3. 상태 이벤트 브로드캐스트:
    - “user-joined”
    - “room-users” (현재 멤버 목록)
    - 또는 “ready-to-negotiate” 같은 신호

> 여기서 누가 “offer를 먼저 만들지(Caller)”를 정해야 해.
> 
> 
> 보통 “방에 **나중에 들어온 사람**이 offer 요청을 보내거나, **서버가 한 명을 caller로 지정**”해.
> 

---

### 1) 미디어 스트림 확보 (카메라/마이크)

**FE (각 사용자 브라우저)**

1. `getUserMedia({ video:true, audio:true })`
2. 내 화면(local video)에 붙임
3. 나중에 PeerConnection에 track 추가할 준비

**BE**

- 없음

> 이 단계는 WebRTC가 아니라 “브라우저 권한/미디어 준비” 단계야.
> 

---

### 2) PeerConnection 생성 + 트랙 추가

**FE**

1. `pc = new RTCPeerConnection({ iceServers: [...] })`
2. `localStream.getTracks().forEach(track => pc.addTrack(track, localStream))`
3. 이벤트 핸들러 등록
    - `pc.onicecandidate` : 후보 생길 때마다 WS로 상대에게 전달
    - `pc.ontrack` : 상대 스트림 들어오면 화면에 렌더

**BE**

- 없음

---

### 3) Offer 생성 & 전달 (시그널링)

**Caller 쪽 FE**

1. `offer = await pc.createOffer()`
2. `await pc.setLocalDescription(offer)`
3. WS로 전달: `signal { type: "offer", sdp: offer.sdp, roomId }`

**BE**

1. 받은 offer를 방의 상대 소켓에게 그대로 전달(중계)
    - “A의 offer → B에게 send”

---

### 4) Answer 생성 & 전달

**Callee 쪽 FE**

1. WS로 offer 받음
2. `await pc.setRemoteDescription(offer)`
3. `answer = await pc.createAnswer()`
4. `await pc.setLocalDescription(answer)`
5. WS로 전달: `signal { type: "answer", sdp: answer.sdp }`

**BE**

1. 받은 answer를 상대에게 전달(중계)
    - “B의 answer → A에게 send”

**Caller 쪽 FE**

1. WS로 answer 받음
2. `await pc.setRemoteDescription(answer)`

> 여기까지 하면 “서로 어떤 코덱으로, 어떤 방식으로 통신할지” 협상이 끝났다고 보면 돼.
> 

---

### 5) ICE Candidate 교환 (실제로 연결되는 핵심 단계)

**FE (양쪽)**

- `pc.onicecandidate`에서 candidate 생길 때마다:
    - WS로 전달: `{ type:"ice", candidate }`

**BE**

- ice 메시지를 상대에게 계속 중계

**FE (상대방)**

- ICE 메시지 받으면:
    - `await pc.addIceCandidate(candidate)`

> ICE가 진짜 중요해. NAT/공유기 환경에서 “어떤 경로로 연결할지” 찾는 과정이라
> 
> 
> candidate 교환이 제대로 안 되면 연결이 안 붙어.
> 

---

### 6) 연결 완료 & 미디어 전송 시작

**FE**

- `pc.connectionState` / `iceConnectionState` 가 `connected` / `completed` 쪽으로 감
- `pc.ontrack`으로 상대 영상/음성 스트림 들어옴
- 이제 영상은 **WebRTC P2P로 계속 흐름**
- WebSocket은 채팅/상태/점수 같은 이벤트용으로 계속 써도 됨

**BE**

- 계속 방 상태만 유지(누가 나갔는지, 재입장 등)

openvidu

gpt로 확인한 openvidu

## OpenVidu 전체 구성 요소 3개

1. **프론트엔드(브라우저)**
- OpenVidu Browser SDK로 “세션 접속 → publish/subscribe” 수행
- 카메라/마이크 권한 얻고 스트림 송출/수신
1. **너희 백엔드(앱 서버)**
- OpenVidu Server에 REST API로 요청해서
    - **Session 생성**
    - **Connection(Token) 발급**
- 그 토큰을 프론트에 내려줌 (보안/권한의 핵심)
1. **OpenVidu Server(+ 미디어 서버)**
- 세션/연결/시그널링 처리
- 미디어 서버(Kurento 또는 Enterprise면 mediasoup 선택 가능)가 WebRTC 스트림 라우팅

---

## 실제 동작 프로세스 (방 입장 → 영상 연결)

### 0) “방/매칭”은 너희 서버가 결정

**FE**

- 사용자가 “방 입장” 클릭 (roomId 또는 matchId)

**BE(앱 서버)**

- 유저 인증/매칭 상태 확인
- roomId를 기준으로 “이 방에 들어갈 자격” 체크
- 이제 OpenVidu에 세션/토큰을 요청할 준비

> 여기까지는 OpenVidu가 아니라, 너희 서비스 로직.
> 

---

### 1) (BE) OpenVidu에 “Session 만들기”

**BE → OpenVidu Server (REST API)**

- `Session` 생성(또는 이미 있으면 그 Session 재사용)
- OpenVidu 문서에서도 “클라이언트 접속 전에 앱 서버가 Session/Connection을 만들어야 한다”고 명시돼 있어.

---

### 2) (BE) “Connection(Token) 발급”

**BE → OpenVidu Server (REST API)**

- 해당 Session에 대해 “Connection” 생성
- 그 결과로 **token**을 받음 (유저 1명당 1개씩 만드는 게 일반적)

**BE → FE**

- FE에 `{ sessionId, token, role(옵션), 기타 메타데이터 }` 반환

> 이 token이 “입장권”이고, 이걸로 OpenVidu에 접속해.
> 

---

### 3) (FE) OpenVidu 세션에 접속(connect)

**FE**

- `OV.initSession()`으로 Session 객체 만들고
- `session.connect(token)`으로 세션에 접속

여기서부터 OpenVidu가 내부적으로 **시그널링(WebSocket/RPC)을 알아서 처리**해줘서,

너희가 **offer/answer/ice를 직접 WS로 주고받는 로직을 크게 줄일 수 있음**.

---

### 4) (FE) 내 카메라/마이크 준비 + publish

**FE**

- 퍼블리셔(Publisher)를 만들면서 카메라/마이크 권한을 얻고(내 스트림 준비)
- `session.publish(publisher)`로 “내 스트림을 세션에 올림”

> 여기서 중요한 변화:
> 
> 
> **직접 구현 P2P**에서는 “내 스트림이 상대 브라우저로 직행”인데,
> 
> **OpenVidu(SFU)**에서는 보통 “내 스트림이 OpenVidu 미디어 서버로 올라가고, 거기서 다른 참가자에게 전달”되는 구조가 일반적이야. (그래서 팀원이 ‘미디어 서버 필요’라고 말하는 맥락이 생김)
> 

---

### 5) (FE) 다른 참가자 스트림 수신(subscribe)

**FE**

- 세션에서 `streamCreated` 이벤트가 오면
- `session.subscribe()` 해서 상대 영상/음성을 받음

이렇게 publish/subscribe 모델로 영상이 붙어.

---

### 6) 종료(leave)

**FE**

- 방 나가기 버튼 → `session.disconnect()`

**BE**

- 필요하면 “게임 결과 저장/매칭 종료 처리”
- 세션 자체를 OpenVidu에서 정리할지(방이 비면 삭제 등) 정책 결정
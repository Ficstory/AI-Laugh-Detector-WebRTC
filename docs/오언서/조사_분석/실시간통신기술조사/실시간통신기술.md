# 실시간 통신 기술 종류

### 목차
- [실시간 통신 기술 종류](#------------)
  * [1. Polling](#1-polling)
    + [**Polling 이란?**](#--polling------)
  * [2. Long Polling](#2-long-polling)
    + [롱폴링이란?](#------)
  * [Polling vs Long Polling](#polling-vs-long-polling)
  * [3. Web Socket](#3-web-socket)
    + [Web Socket 이란?](#web-socket----)
  * [4. Server Sent Event(SSE)](#4-server-sent-event-sse-)
    + [SSE 란?](#sse---)
  * [웹 소켓 vs SSE](#-----vs-sse)
- [🌟 우리 프로젝트에는 뭐가 더 적합할까?](#-----------------------)



## 1. Polling

### **Polling 이란?**

- 클라이언트가 일정한 주기마다 서버에 요청을 보내 새로운 데이터가 있는지 확인하는 통신 방식

**원리**

클라이언트가 일정 주기마다 서버에 “새로운 데이터가 있나요?”하고 묻는 요청을 보냄

- 새로운 데이터가 없으면: `빈 응답`이나 `204 No Content` 상태 코드를 실어 응답
- 새로운 데이터가 있으면: 최신 정보를 본문에 실어 응답

**예시**

- 초기의 채팅 애플리케이션이나 단순한 알림 시스템에 적합

**특징과 한계**

- **단순한 구현**
    - 기존 HTTP 요청/응답 구조 사용(특별한 프로토콜 필요 X)
- **제한적 실시간성**
    - 요청 주기가 길면 업데이트 지연, 짧게 잡으면 서버 부담
- **많은 트래픽**
    - 데이터가 없어도 계속 요청을 보냄 + 사용자 수가 많을 수록 트래픽이 더 늘어남

## 2. Long Polling

### 롱폴링이란?

- HTTP를 통해 클라이언트와 서버 간의 실시간 통신을 구현하는 기술
- 클라이언트가 요청하고 서버가 응답하는 단방향 환경을 위해 설계된 웹 플랫폼에서 양방향 애플리케이션을 구축하는 문제를 해결

**원리**

1. 클라이언트가 서버에 GET 요청을 보냄
    - 일반적인 HTTP 요청과는 달리, 응답을 특정하지 않고 언제든 응답 가능
2. 시간 경과
    - 매우 길거나 무기한의 타임아웃 기간을 설정 가능 → 서버가 즉시 응답하지 않더라도 요청이 계속 열려 있도록
3. 서버 응답
    - 서버가 전송할 내용이 있으면 응답과 함께 연결 종료
4. 클라이언트가 새로운 GET 요청을 보내면 이 과정이 다시 시작

**장점**

- 폭넓은 호환성
    - 모든 최신 브라우저, HTTP 클라이언트 및 프록시 설정과 호환됨
- 방화벽 호환성
    - WebSocket 연결을 차단하려는 여러 제한 사항 우회

**단점**

- 부하가 걸리면 비효율적임
    - 각 클라이언트가 열린 연결을 유지하므로 서버 리소스(스레드, 메모리)를 소모함
- 웹소켓보다 지연 시간이 더 긺
    - 특히 서버 응답 시간이나 타임아웃 간격이 세밀하게 조정되지 않은 경우
- 복잡한 클라이언트 로직
    - 재시도 처리, 지수 백오프 및 타임아웃 관리 필요
- 확장성 부족
    - 대규모 사용자 기반을 위해 장기 폴링 인프라를 수평적으로 확장하는 것은 상당한 운영 오버헤드 없이 어려움
- 구현 방식에 따라 메시지 중복 또는 순서 문제가 발생할 수 있음

**적합한 서비스**

- 실시간 메시지 전달이 중요하지만, 잦은 데이터 전달이 없는P 경우

## Polling vs Long Polling

| 구분 | Polling | Long Polling |
| --- | --- | --- |
| 기본 개념 | 클라이언트가 일정 주기마다 서버에 요청 | 클라이언트가 요청 후 서버가 데이터가 생길 때까지 대기 |
| 요청 방식 | 주기적 반복 요청 | 요청 1회 → 응답 후 다시 요청 |
| 서버 응답 시점 | 요청 즉시 응답 | 데이터가 생기거나 타임아웃 시 응답 |
| 데이터 없을 때 | 빈 응답 반복 | 응답 지연 후 타임아웃 |
| 실시간성 | 낮음 (주기에 의존) | Polling보다 높음 |
| 트래픽 사용 | 불필요한 요청 많음 | 불필요한 요청 감소 |
| 서버 리소스 | 비교적 적음 | 연결 유지로 더 많이 사용 |
| 구현 난이도 | 쉬움 | 상대적으로 복잡 |
| 적합한 상황 | 단순 상태 확인, 비실시간 기능 | 비교적 실시간이 필요한 알림/메시지 |

## 3. Web Socket

### Web Socket 이란?

- 양방향 통신을 가능하게 하는 프로토콜
- 웹 소켓이 연결되어 있는 한 클라이언트와 서버 간에 실시간으로 데이터를 주고 받을 수 있음

**작동 원리**

1. TCP/IP 접속 요청
2. TCP/IP 접속 수락
3. 웹소켓 열기 핸드쉐이크 요청
4. 웹소켓 열기 핸드쉐이크 수락
5. 웹소켓 데이터 송, 수신

**특징과 장점**

- **TCP 연결**을 기반으로 하기 때문에 **한 번의 핸드셰이크**를 통해 연결이 이루어짐
- HTTP 프로토콜을 사용하여 초기 연결을 설정
    - 기존 웹 인프라와의 호환성을 위해 HTTP 로 연결을 시작
    - 이후는 TCP 위에서 HTTP → WebSocket 프로토콜로 업그레이드 하여 실시간 양방향 통신을 가능하게 함
    - HTTP → WebSocket 업그레이드란?
        
        클라이언트가  “이 TCP 연결 이제부터 웹소켓으로 쓰고 싶어요”라고 함
        
        서버:
        
        ```
        HTTP/1.1 101 Switching Protocols
        Upgrade: websocket
        Connection: Upgrade
        ```
        
        👉 이 순간 이후
        
        - HTTP 규칙 X
        - 요청/응답 X
        - 헤더 X
        - 웹 소켓 프레임 규칙만 사용
        
    
    **굳이 HTTP 로 시작하는 이유**
    
    - 방화벽, 프록시, 로드밸런서 통과
        
        현실의 네트워크
        
        - 회사/학교/카페 네트워크
        - 프록시 서버
        - L7 로드밸런서
        - 방화벽
        
        👉 등 대부분은 HTTP/HTTPS 만 통과시킴
        
        👉 갑자기 순수 TCP 프로토콜을 쓰면 차단당함.
        
        따라서 다음과 같이 요청
        
        ```
        GET /chat HTTP/1.1
        Host: example.com
        Upgrade: websocket
        Connection: Upgrade
        ```
        
        👉 그러면 모든 웹 인프라를 안전하게 통과
        
    - 기존 웹 서버와 완벽 호환
        
        웹 서버는 이미
        
        - HTTP 요청 처리
        - 인증(쿠키, 헤더)
        - 세션
        - 로깅
        
        등을 다 가지고 있음
        
        웹 소켓이 HTTP 로 시작하면
        
        - 쿠키 그대로 사용 가능
        - JWT/세션 인증 재사용 가능
        - 같은 포트(80, 443) 사용 가능
        
        👉 서버 구조를 새로 만들 필요가 없음
        
    - HTTPS 보안 그대로 가져오기
        
        웹소켓 보안 버전
        
        - ws:// → HTTP
        - wss:// → HTTPS(TLS)
        
        👉 TLS 핸드셰이크는 HTTP 단계에서 이미 끝남
        
        이후 데이터는 암호화된 TCP 스트림 위에서 실시간 전송
        
        즉, 
        
        - 보안 직접 구현 X
        - HTTPS 보안 그대로 재사용
        
- HTML5 표준의 일부로, 대부분의 최신 웹 브라우저에서 지원

**적합한 서비스**

- 양방향 통신이 필요하고, socket 통신을 위한 전용 서버를 구축할 환경이 되는 곳
- ex. LOL 같은 멀티플레이어 게임, 위치 기반 app, 화상채팅 app

## 4. Server Sent Event(SSE)

### SSE 란?

- 서버에서 클라이언트로 데이터를 단방향으로 전송하는 기술
- HTTP/1.1의 지속 연결을 활용하여 데이터를 스트리밍 방식으로 전송
    - HTTP/1.1 연결이란?
        
        하나의 TCP 연결을 열어두고 여러 HTTP 요청/응답을 처리할 수 잇게 만든 방
        

**특징**

- 단방향 데이터 전송만 가능
    - 클라이언트에서 서버로 데이터를 보낼 수 X
- 텍스트 데이터만 전송 가능
    - 바이너리 데이터는지원 X
- Internet Explorer 는 미지원

**적합한 서비스**

- 서버에서 일방적인 데이터 전달이 필요한 곳
    - ex. 스트리밍 서비스, 스포츠 점수 경기판, 주식 시세 업데이트, 알림 시스템 등

## 웹 소켓 vs SSE

| 특징 | SSE | 웹소켓 |
| --- | --- | --- |
| 데이터 전송 방향 | 단방향 | 양방향 |
| 프로토콜 | HTTP 기반 | TCP 기반 |
| 데이터 유형 | 텍스트만 지원 | 텍스트 및 바이너리 지원 |
| 브라우저 지원 | 일부 브라우저에서 제한적 | 대부분의 브라우저에서 지원 |

<aside>
> 💡 HTTP vs TCP 통신<br>
HTTP 통신: 클라이언트가 요청을 보내면 서버가 응답을 주는 방식의 통신 방식
TCP 통신: 두 장치가 먼저 연결을 맺고 그 연결을 유지한 채로 데이터를 주고 받는 형식

</aside>

---

# 🌟 우리 프로젝트에는 뭐가 더 적합할까?

우리 프로젝트는 화상회의를 통해 사용자들이 실시간으로 양방향 소통하는 기능이 핵심이 게임이다. 따라서, 서버에서 클라이언트로만 데이터를 전달하는 단방향 통신인 SSE, 폴링, 롱폴링 방식은 요구사항에 적합하지 않아 제외하였다.

또한, 다양한 네트워크 환경에서도 안정적으로 연결하기 위해 HTTP 로 연결을 시작하여 기존 웹 인프라와 호환성을 유지할 수 있는 방식이 필요하였고,  한 번 연결하면 이후 지속적으로 요청할 필요없이 계속 송수신이 가능한 통신 방식이 적합하다고 생각했다. 

만약 데이터를 받기 위해 지속적인 요청이 필요하다면 사용자 수가 증가할 수록 불필요한 트래픽이 다량 발생하여 성능에 무리가 간다고 판단하였기 때문이다. 이러한 이유로 우리 프로젝트에 적합한 실시간 통신 기술로 웹소켓을 채택하였다.

---

참고자료

https://4sii.tistory.com/325

https://www.inflearn.com/blogs/13200?srsltid=AfmBOorYKelt4dSuV_Lbg0hW75iwm8TxZorCnD8M-p9UmDE28R7MZZYS

http://www.ktword.co.kr/test/view/view.php?no=618

https://ably.com/topic/long-polling?utm_source=chatgpt.com

https://f-lab.kr/insight/websocket-vs-rest-api?gad_source=1&gad_campaignid=22368870602&gbraid=0AAAAACGgUFddDhN-2jLPHrvwUX96JWvwM&gclid=CjwKCAiA95fLBhBPEiwATXUsxPKOuOf4N66f7Lwr5e0FCvkQGsd_4E0x_6XbcjlUJ8ksjAkygATyMxoC3jAQAvD_BwE

https://yuricoding.tistory.com/134#google_vignette

https://f-lab.kr/insight/sse-vs-websocket-20250617?gad_source=1&gad_campaignid=22368870602&gbraid=0AAAAACGgUFddDhN-2jLPHrvwUX96JWvwM&gclid=CjwKCAiA95fLBhBPEiwATXUsxKEnmAtGzvQbjB30gnDcP2e1YPT6OzRpvVmp_XIAmiyfHIzUqV2AuhoCrw0QAvD_BwE